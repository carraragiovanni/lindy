const canvas = document.getElementById('canvas3d'); const ctx = canvas.getContext('2d'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; const points = []; const numPoints = 8; const size = 100; for(let i = 0; i < numPoints; i++) { points.push({ x: Math.cos(i/numPoints * Math.PI * 2) * size, y: Math.sin(i/numPoints * Math.PI * 2) * size, z: size }); points.push({ x: Math.cos(i/numPoints * Math.PI * 2) * size, y: Math.sin(i/numPoints * Math.PI * 2) * size, z: -size }); } let rotation = 0; function project(point) { const perspective = 300; const scale = perspective / (perspective + point.z); return { x: point.x * scale + canvas.width/2, y: point.y * scale + canvas.height/2 }; } function rotatePoint(point) { const cos = Math.cos(rotation); const sin = Math.sin(rotation); const y = point.y * cos - point.z * sin; const z = point.y * sin + point.z * cos; const x = point.x * cos - z * sin; return {x, y, z: point.x * sin + z * cos}; } function animate() { ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = `hsl(${rotation * 50}, 70%, 60%)`; ctx.lineWidth = 2; const rotatedPoints = points.map(p => rotatePoint(p)); for(let i = 0; i < rotatedPoints.length; i++) { for(let j = i + 1; j < rotatedPoints.length; j++) { const p1 = project(rotatedPoints[i]); const p2 = project(rotatedPoints[j]); ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); } } rotation += 0.02; requestAnimationFrame(animate); } animate(); window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });